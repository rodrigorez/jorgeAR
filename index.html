<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Scene - Version 2 (AR Integration)</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <!-- Biblioteca A-Frame -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <!-- AR.js para A-Frame: Habilita Realidade Aumentada baseada em marcadores -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <!-- Orbit Controls para o modo Debug/Mouse (o mesmo da Versão 1) -->
    <script src="https://unpkg.com/aframe-orbit-controls@1.3.2/dist/aframe-orbit-controls.min.js"></script>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
        }

        /* Removido display: flex para não conflitar com o redimensionamento interno do AR.js */

        header {
            background: linear-gradient(135deg, rgba(30, 30, 30, 0.9) 0%, rgba(10, 10, 10, 0.8) 100%);
            backdrop-filter: blur(5px);
            color: #ffffff;
            padding: 10px 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            z-index: 2000;
            position: fixed;
            top: 0;
            width: 100%;
            box-sizing: border-box;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        header h3 {
            margin: 2px 0;
            font-weight: 300;
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            letter-spacing: 0.5px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* Tela de carregamento do AR.js */
        .arjs-loader {
            height: 100vh;
            width: 100vw;
            position: fixed;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2rem;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
    </style>
</head>

<body style="margin: 0px; overflow: hidden;">
    <!-- Loader: Exibido enquanto a câmera e os marcadores carregam -->
    <div class="arjs-loader">
        <div>Carregando experiência de Realidade Aumentada...</div>
    </div>

    <header>
        <h3>Algoritmos de Programação de Computação Gráfica 3D e Arte Digital em 3D.</h3>
        <h3>Reflection and Refraction through 3D AR Algorithms.</h3>
    </header>

    <!-- Cena A-Frame com configuração AR.js -->
    <a-scene embedded
        arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
        vr-mode-ui="enabled: false" renderer="antialias: true; colorManagement: true; alpha: true;">

        <!-- Iluminação: Essencial para o Modo Debug (objetos não ficarem pretos) -->
        <a-light type="ambient" color="#ffffff" intensity="0.6"></a-light>
        <a-light type="point" position="0 2 1" intensity="0.8"></a-light>

        <!-- Marcador HIRO: O conteúdo 3D será ancorado aqui -->
        <a-marker preset="hiro" id="main-marker" smooth="true" smoothCount="10" smoothTolerance="0.01"
            smoothThreshold="5">
            <!-- CONTEÚDO PARA RA: Usa o componente jorge-world-content para sincronia -->
            <a-entity id="ar-world-root" jorge-world-content="forceOpaque: false" visible="true"></a-entity>
        </a-marker>

        <!-- Ponto de ancoragem estático para o Modo Debug (CONTEÚDO PARA DEBUG) -->
        <a-entity id="static-debug-root" visible="false">
            <!-- CONTEÚDO PARA DEBUG: Usa o MESMO componente com opacidade forçada -->
            <a-entity id="debug-world-content" jorge-world-content="forceOpaque: true"></a-entity>
        </a-entity>

        <!-- Câmeras -->
        <!-- O AR.js precisa que a câmera padrão seja a ativa no início -->
        <a-entity id="ar-camera-rig">
            <a-entity id="ar-camera" camera position="0 0 0"></a-entity>
        </a-entity>

        <!-- Câmera de Debug (Orbit Controls) -->
        <a-entity id="debug-rig" visible="false">
            <a-entity id="debug-camera" camera="active: false" look-controls
                orbit-controls="target: 0 0 0; minDistance: 0.1; maxDistance: 5; initialPosition: 0 0.5 1; autoRotate: false;">
            </a-entity>
        </a-entity>
    </a-scene>

    <script>
        /**
         * COMPONENTE Jorge WORLD CONTENT
         * Centraliza a geometria 3D para garantir que o que mudar aqui muda em RA e Debug.
         */
        AFRAME.registerComponent('jorge-world-content', {
            schema: {
                forceOpaque: { type: 'boolean', default: false }
            },
            init: function () {
                const el = this.el;
                const forceOpaque = this.data.forceOpaque;
                el.setAttribute('scale', '3 3 3');

                // Círculo Base (Sempre transparente)
                const baseCircle = document.createElement('a-entity');
                baseCircle.setAttribute('geometry', 'primitive: cylinder; radius: 0.14; height: 0.005;');
                baseCircle.setAttribute('material', {
                    color: '#0000ff',
                    transparent: true,
                    opacity: 0.4,
                    depthWrite: false
                });
                el.appendChild(baseCircle);

                // Linhas Vermelhas (Alinhamento de Precisão para Ângulos Retos)
                const lines = document.createElement('a-entity');
                const lineThickness = 0.0045;
                const lineConfigs = [
                    // Esquerda (X = -0.025, W = 0.09)
                    { pos: "-0.025 0.001 0.0791", w: 0.009, h: 0.002, d: 0.0767 }, // Superior Vertical
                    { pos: "-0.025 0.001 -0.0441", w: 0.009, h: 0.002, d: 0.1267 }, // Inferior Vertical
                    { pos: "-0.0477 0.001 0.043", w: 0.0545, h: 0.002, d: lineThickness }, // Superior Horizontal
                    { pos: "-0.0477 0.001 0.017", w: 0.0545, h: 0.002, d: lineThickness }, // Inferior Horizontal

                    // Direita (X = 0.045, W = 0.0045)
                    { pos: "0.0689 0.001 0.043", w: 0.0522, h: 0.002, d: lineThickness }, // Superior Horizontal
                    { pos: "0.0689 0.001 0.017", w: 0.0522, h: 0.002, d: lineThickness }, // Inferior Horizontal
                    { pos: "0.045 0.001 0.0781", w: 0.0045, h: 0.002, d: 0.0747 }, // Superior Vertical
                    { pos: "0.045 0.001 -0.0441", w: 0.0045, h: 0.002, d: 0.1267 } // Inferior Vertical
                ];
                lineConfigs.forEach(conf => {
                    const line = document.createElement('a-box');
                    line.setAttribute('position', conf.pos);
                    line.setAttribute('width', conf.w);
                    line.setAttribute('height', conf.h);
                    line.setAttribute('depth', conf.d);
                    line.setAttribute('material', 'color: #ff0000; transparent: false; opacity: 1;');
                    lines.appendChild(line);
                });
                el.appendChild(lines);

                // Instrumentos
                const createInst = (pos, tipPos, tipRot) => {
                    // inst
                    const inst = document.createElement('a-entity');
                    inst.setAttribute('position', pos);
                    const tip = document.createElement('a-entity');
                    tip.setAttribute('position', tipPos);

                    // cone (Sempre Opaco)
                    tip.setAttribute('geometry', 'primitive: cone; radiusBottom: 0.0025; radiusTop: 0.0001; height: 0.005; segmentsRadial: 32;');
                    if (tipRot) tip.setAttribute('rotation', tipRot);
                    tip.setAttribute('material', 'color: #ad9312; transparent: false; opacity: 1;');
                    inst.appendChild(tip);

                    // cylinder (Sempre Opaco)
                    const cylinder = document.createElement('a-cylinder');
                    cylinder.setAttribute('radius', 0.00125);
                    cylinder.setAttribute('height', 0.02);
                    cylinder.setAttribute('material', 'color: #ad9312; transparent: false; opacity: 1;');
                    inst.appendChild(cylinder);

                    // cube (Mantido comentado para futura manutenção)
                    /*
                    const cube = document.createElement('a-box');
                    cube.setAttribute('width', 0.02);
                    cube.setAttribute('height', 0.02);
                    cube.setAttribute('depth', 0.02);
                    cube.setAttribute('material', {
                        color: '#ad9312',
                        transparent: true,
                        opacity: 0.4,
                        depthWrite: false
                    });
                    inst.appendChild(cube);
                    */
                    return inst;
                };
                el.appendChild(createInst("0.008 0.011 0.09", "0 0.01 0", "0 0 0"));
                el.appendChild(createInst("0.008 -0.012 0.04", "0 -0.01 0", "180 0 0"));

                // Pirâmides (Sempre Transparentes)
                const createPyramid = (pos, color, rot, opacity) => {
                    const pyramid = document.createElement('a-entity');
                    pyramid.setAttribute('position', pos);
                    pyramid.setAttribute('geometry', 'primitive: cone; radiusBottom: 0.025; radiusTop: 0.0001; height: 0.0415; segmentsRadial: 4;');
                    pyramid.setAttribute('rotation', rot);
                    pyramid.setAttribute('material', {
                        color: color,
                        transparent: true,
                        opacity: opacity,
                        emissive: color === '#ffffff' ? '#111' : '#000',
                        depthWrite: false
                    });
                    return pyramid;
                };

                // Pirâmide Superior (Branca)
                el.appendChild(createPyramid("0.008 0.02075 0.09", "#ffffff", "0 45 0", 0.5));
                // Pirâmide Inferior (Vermelha)
                el.appendChild(createPyramid("0.008 -0.02075 0.04", "#ff0000", "180 45 0", 0.4));
            }
        });

        window.addEventListener('arjs-video-loaded', function () {
            document.querySelector('.arjs-loader').style.display = 'none';
        });

        /**
         * Garante que a cena do A-Frame e o feed da câmera se ajustem
         * corretamente se o usuário redimensionar a janela do navegador.
         */
        var isDebugMode = false;
        function toggleDebugMode() {
            isDebugMode = !isDebugMode;
            var arCamera = document.getElementById('ar-camera');
            var debugCamera = document.getElementById('debug-camera');
            var arContent = document.getElementById('ar-world-root');
            var debugRoot = document.getElementById('static-debug-root');
            var scene = document.querySelector('a-scene');
            var video = document.querySelector('video');

            if (isDebugMode) {
                // --- ATIVAR MODO DEBUG ---
                console.log("Modo Debug Ativado");

                // 1. Esconder conteúdo RA e mostrar conteúdo Debug
                arContent.setAttribute('visible', false);
                debugRoot.setAttribute('visible', true);

                // 2. Alternar Câmeras
                arCamera.setAttribute('camera', 'active', false);
                debugCamera.setAttribute('camera', 'active', true);
                document.getElementById('debug-rig').setAttribute('visible', true);

                // 3. Ajustar Visual
                if (video) video.style.display = 'none';
                scene.setAttribute('background', 'color: #1980cc');

                if (scene.systems.arjs) scene.systems.arjs.pause();
            } else {
                // --- ATIVAR MODO RA ---
                console.log("Modo RA Ativado");

                // 1. Inverter visibilidade
                arContent.setAttribute('visible', true);
                debugRoot.setAttribute('visible', false);

                // 2. Alternar Câmeras
                debugCamera.setAttribute('camera', 'active', false);
                arCamera.setAttribute('camera', 'active', true);
                document.getElementById('debug-rig').setAttribute('visible', false);

                // 3. Restaurar Feed
                if (video) video.style.display = 'block';
                scene.removeAttribute('background');

                if (scene.systems.arjs) scene.systems.arjs.play();
            }
        }

        /**
         * GATILHOS INVISÍVEIS:
         * 1. Atalho: Ctrl+M ou Cmd+M (Desktop)
         * 2. Gesto: 5 Cliques rápidos (Celular/Desktop)
         */

        // Atalho de Teclado
        window.addEventListener('keydown', function (e) {
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'm') {
                e.preventDefault();
                toggleDebugMode();
            }
        });

        // Gesto de 5 Cliques
        var clickCount = 0;
        var lastClickTime = 0;
        window.addEventListener('click', function () {
            var currentTime = new Date().getTime();
            if (currentTime - lastClickTime < 500) {
                clickCount++;
            } else {
                clickCount = 1;
            }
            lastClickTime = currentTime;

            if (clickCount >= 5) {
                clickCount = 0;
                toggleDebugMode();
            }
        });

        window.addEventListener('resize', function () {
            var scene = document.querySelector('a-scene');
            if (scene) scene.resize();
        });

        // Suporte extra para mudança de orientação em dispositivos móveis
        window.addEventListener('orientationchange', function () {
            setTimeout(function () {
                var scene = document.querySelector('a-scene');
                if (scene) scene.resize();
            }, 300);
        });
    </script>
</body>

</html>